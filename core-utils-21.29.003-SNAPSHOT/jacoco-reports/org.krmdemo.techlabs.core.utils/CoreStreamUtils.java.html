<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CoreStreamUtils.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">core-utils</a> &gt; <a href="index.source.html" class="el_package">org.krmdemo.techlabs.core.utils</a> &gt; <span class="el_source">CoreStreamUtils.java</span></div><h1>CoreStreamUtils.java</h1><pre class="source lang-java linenums">package org.krmdemo.techlabs.core.utils;

import java.util.AbstractMap;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.NavigableMap;
import java.util.NavigableSet;
import java.util.SequencedMap;
import java.util.SequencedSet;
import java.util.stream.IntStream;
import java.util.stream.Stream;
import java.util.stream.StreamSupport;

import static org.krmdemo.techlabs.core.utils.CoreCollectors.toLinkedListReversed;
import static org.krmdemo.techlabs.core.utils.CoreCollectors.toLinkedMap;
import static org.krmdemo.techlabs.core.utils.CoreCollectors.toLinkedSet;
import static org.krmdemo.techlabs.core.utils.CoreCollectors.toListReversed;
import static org.krmdemo.techlabs.core.utils.CoreCollectors.toSortedMap;
import static org.krmdemo.techlabs.core.utils.CoreCollectors.toSortedSet;

/**
 * Utility-class that provides methods to transform the stream or var-args-arrays of values into linked or sorted sets
 * and stream or var-args-arrays of {@link Map.Entry entries} into linked or sorted map.
 * An enumeration {@link MergeFunction} could be used to handle the entries with the same {@link Map.Entry#getKey() key}.
 * &lt;hr/&gt;
 * Some miscellaneous helper utility-methods to work with primitive streams are also added...
 */
public class CoreStreamUtils {

    // ===========================================================================================
    //            Utility-methods to convert IntStreams to List&lt;Integer&gt;
    // ===========================================================================================

    /**
     * @param intsArr array of primitive {@code int}s
     * @return a {@link List} of {@link Integer}
     */
    public static List&lt;Integer&gt; intsList(int... intsArr) {
<span class="fc" id="L42">        return intsList(IntStream.of(intsArr));</span>
    }

    /**
     * @param ints stream of primitive {@code int}s
     * @return a {@link List} of {@link Integer}
     */
    public static List&lt;Integer&gt; intsList(IntStream ints) {
<span class="fc" id="L50">        return ints.boxed().toList();</span>
    }

    /**
     * @param startInclusive the lower bound of the range (inclusive)
     * @param endExclusive the higher bound of the range (exclusive)
     * @return the {@link List} of all {@link Integer} in the range {@code [ startInclusive ; endExclusive )}
     */
    public static List&lt;Integer&gt; intsListRange(int startInclusive, int endExclusive) {
<span class="nc" id="L59">        return intsList(IntStream.range(startInclusive, endExclusive));</span>
    }

    /**
     * @param startInclusive the lower bound of the range (inclusive)
     * @param endInclusive the higher bound of the range (inclusive)
     * @return the {@link List} of all {@link Integer} in the range {@code [ startInclusive ; endInclusive ]}
     */
    public static List&lt;Integer&gt; intsListRangeClosed(int startInclusive, int endInclusive) {
<span class="nc" id="L68">        return intsList(IntStream.rangeClosed(startInclusive, endInclusive));</span>
    }

    /**
     * Un-boxing the stream of {@link Integer}s
     *
     * @param integers the stream of {@link Integer}s to un-box
     * @return the stream of primitive {@code int}s
     */
    public static IntStream intStream(Stream&lt;Integer&gt; integers) {
<span class="nc" id="L78">        return integers.mapToInt(Integer::intValue);</span>
    }

    /**
     * @param integersList a {@link List} of {@link Integer}
     * @return the stream of primitive {@code int}s
     */
    public static IntStream intStream(List&lt;Integer&gt; integersList) {
<span class="nc" id="L86">        return intStream(integersList.stream());</span>
    }

    // ===========================================================================================
    //        Utility-methods to create a reverse streams from the given array or list
    // ===========================================================================================

    public static IntStream reversed(int... valuesArr) {
<span class="fc" id="L94">        return IntStream.rangeClosed(1, valuesArr.length).map(i -&gt; valuesArr[valuesArr.length - i]);</span>
    }
    public static IntStream reversed(List&lt;Integer&gt; valuesList) {
<span class="nc" id="L97">        return IntStream.rangeClosed(1, valuesList.size()).map(i -&gt; valuesList.get(valuesList.size() - i));</span>
    }

    public static int[] reversedArr(int... valuesArr) {
<span class="fc" id="L101">        return reversed(valuesArr).toArray();</span>
    }
    public static int[] reversedArr(java.util.stream.IntStream values) {
<span class="nc" id="L104">        return reversedArr(values.toArray());</span>
    }

    public static ArrayList&lt;Integer&gt; reversedList(int... valuesArr) {
<span class="nc" id="L108">        return reversedList(Arrays.stream(valuesArr).boxed());</span>
    }
    public static ArrayList&lt;Integer&gt; reversedList(IntStream values) {
<span class="nc" id="L111">        return reversedList(values.boxed());</span>
    }
    public static &lt;T&gt; ArrayList&lt;T&gt; reversedList(Stream&lt;T&gt; boxedStream) {
<span class="nc" id="L114">        return boxedStream.collect(toListReversed());</span>
    }
    public static &lt;T&gt; ArrayList&lt;T&gt; reversedList(List&lt;T&gt; valuesList) {
<span class="nc" id="L117">        return reversedList(valuesList.stream());</span>
    }

    public static LinkedList&lt;Integer&gt; reversedLinkedList(int... valuesArr) {
<span class="nc" id="L121">        return reversedLinkedList(Arrays.stream(valuesArr).boxed());</span>
    }
    public static LinkedList&lt;Integer&gt; reversedLinkedList(IntStream values) {
<span class="nc" id="L124">        return reversedLinkedList(values.boxed());</span>
    }
    public static &lt;T&gt; LinkedList&lt;T&gt; reversedLinkedList(Stream&lt;T&gt; boxedStream) {
<span class="nc" id="L127">        return boxedStream.collect(toLinkedListReversed());</span>
    }
    public static &lt;T&gt; LinkedList&lt;T&gt; reversedLinkedList(List&lt;T&gt; valuesList) {
<span class="nc" id="L130">        return reversedLinkedList(valuesList.stream());</span>
    }

    // --------------------------------------------------------------------------------------------

    /**
     * Getting the {@link Stream} of elements in passed {@link Iterable}.
     * &lt;hr/&gt;
     * &lt;u&gt;&lt;i&gt;Note:&lt;/i&gt;&lt;/u&gt; the returned stream could be used only once, but the construction is very chip
     * from performance and memory foot-print point of view - so, there's no problem to invoke this method multiple times.
     *
     * @param elems elements to get the {@link Stream} of
     * @return a sequential {@link Stream} of elements in {@code elems}
     * @param &lt;T&gt; a type of elements in {@code elems}
     */
    public static &lt;T&gt; Stream&lt;T&gt; streamOf(Iterable&lt;T&gt; elems) {
<span class="fc" id="L146">        return StreamSupport.stream(elems.spliterator(), false);</span>
    }

    /**
     * This method returns the {@link List}, which appears to be two whole copy of {@code elems}.
     * The order of elements in the first and the second copy remains exactly the same as in original {@link Iterable}.
     *
     * @param elems elements to &lt;i&gt;multiply twice&lt;/i&gt;
     * @return the {@link List}, which appears to be two whole copy of {@code elems}
     * @param &lt;T&gt; a type of elements in {@code elems}
     */
    public static &lt;T&gt; List&lt;T&gt; listTwiceOf(Iterable&lt;T&gt; elems) {
<span class="fc" id="L158">        return Stream.concat(streamOf(elems), streamOf(elems)).toList();</span>
    }

    // --------------------------------------------------------------------------------------------

    /**
     * @param valuesArr var-args-arrays of values
     * @return the sorted set of those values as {@link NavigableSet}
     * @param &lt;T&gt; the type of value that must implement {@link Comparable}
     */
    @SafeVarargs
    @SuppressWarnings(&quot;varargs&quot;)
    public static &lt;T extends Comparable&lt;T&gt;&gt; NavigableSet&lt;T&gt; sortedSet(T... valuesArr) {
<span class="fc" id="L171">        return sortedSet(Arrays.stream(valuesArr));</span>
    }

    /**
     * @param values stream of values
     * @return the sorted set of those values as {@link NavigableSet}
     * @param &lt;T&gt; the type of value that must implement {@link Comparable}
     */
    public static &lt;T extends Comparable&lt;T&gt;&gt; NavigableSet&lt;T&gt; sortedSet(Stream&lt;T&gt; values) {
<span class="fc" id="L180">        return values.collect(toSortedSet());</span>
    }

    /**
     * @param valuesIter collection of values as {@link Iterable}
     * @return the sorted set of those values as {@link NavigableSet}
     * @param &lt;T&gt; the type of elements that must implement {@link Comparable}
     */
    public static &lt;T extends Comparable&lt;T&gt;&gt; NavigableSet&lt;T&gt; sortedSet(Iterable&lt;T&gt; valuesIter) {
<span class="nc" id="L189">        return sortedSet(StreamSupport.stream(valuesIter.spliterator(), false));</span>
    }

    /**
     * @param valuesArr var-args-arrays of values
     * @return the linked set of those values as {@link SequencedSet}
     * @param &lt;T&gt; the type of elements
     */
    @SafeVarargs
    @SuppressWarnings(&quot;varargs&quot;)
    public static &lt;T&gt; SequencedSet&lt;T&gt; linkedSet(T... valuesArr) {
<span class="fc" id="L200">        return linkedSet(Arrays.stream(valuesArr));</span>
    }

    /**
     * @param values stream of values
     * @return the linked set of those values as {@link SequencedSet}
     * @param &lt;T&gt; the type of elements
     */
    public static &lt;T&gt; SequencedSet&lt;T&gt; linkedSet(Stream&lt;T&gt; values) {
<span class="fc" id="L209">        return values.collect(toLinkedSet());</span>
    }

    /**
     * @param valuesIter collection of values as {@link Iterable}
     * @return the linked set of those values as {@link SequencedSet}
     * @param &lt;T&gt; the type of elements
     */
    public static &lt;T&gt; SequencedSet&lt;T&gt; linkedSet(Iterable&lt;T&gt; valuesIter) {
<span class="nc" id="L218">        return linkedSet(StreamSupport.stream(valuesIter.spliterator(), false));</span>
    }

    /**
     * A factory-method to produce an instance of {@link Map.Entry} from {@code key} and {@code value}.
     *
     * @param key a key of entry to create
     * @param value a value of entry to create
     * @return an instance of {@link Map.Entry} as {@link AbstractMap.SimpleEntry}
     * @param &lt;K&gt; the type of key
     * @param &lt;V&gt; the type of value
     */
    public static &lt;K, V&gt; Map.Entry&lt;K, V&gt; keyValue(K key, V value) {
<span class="fc" id="L231">        return new AbstractMap.SimpleEntry&lt;&gt;(key, value);</span>
    }

    /**
     * The same as {@link #keyValue(Object, Object) keyValue(K key, V value)},
     * but when the type of {@code key} is {@link String} (we can call such {@code key} as {@code name} in this case).
     *
     * @param name a name of entry to create
     * @param value a value of entry to create
     * @return an instance of {@link Map.Entry} as {@link AbstractMap.SimpleEntry}
     * @param &lt;V&gt; the type of value
     */
    public static &lt;V&gt; Map.Entry&lt;String, V&gt; nameValue(String name, V value) {
<span class="fc" id="L244">        return keyValue(name, value);</span>
    }

    /**
     * Transform the var-args-arrays of entries into the sorted map,
     * where the entries with the same {@link Map.Entry#getKey() key} are merged
     * with the default merge-function {@link MergeFunction#OVERWRITE}.
     * &lt;hr/&gt;
     * In order to avoid {@link NullPointerException} all invalid entries are filtered out,
     * where the filter is based on using {@link #entryIsValid(Map.Entry)} function.
     *
     * @param entriesArr var-args-arrays of entries
     * @return the sorted map, which is collected from those entries, as {@link NavigableMap},
     * @param &lt;K&gt; the type of key that must implement {@link Comparable}
     * @param &lt;V&gt; the type of value
     */
    @SafeVarargs
    @SuppressWarnings(&quot;varargs&quot;)
    public static &lt;K extends Comparable&lt;K&gt;, V&gt; NavigableMap&lt;K, V&gt;
    sortedMap(Map.Entry&lt;K,V&gt;... entriesArr) {
<span class="fc" id="L264">        return sortedMap(Arrays.stream(entriesArr).filter(CoreStreamUtils::entryIsValid));</span>
    }

    /**
     * Transform the var-args-arrays of entries into the sorted map,
     * where the entries with the same {@link Map.Entry#getKey() key} are merged
     * with the passed {@code mergeFunction}.
     * &lt;hr/&gt;
     * In order to avoid {@link NullPointerException} all invalid entries are filtered out,
     * where the filter is based on using {@link #entryIsValid(Map.Entry)} function.
     *
     * @param mergeFunction the merge-function to handle the entries with the same {@link Map.Entry#getKey() key}
     * @param entriesArr var-args-arrays of entries
     * @return the sorted map, which is collected from those entries, as {@link NavigableMap},
     * @param &lt;K&gt; the type of key that must implement {@link Comparable}
     * @param &lt;V&gt; the type of value
     */
    @SafeVarargs
    @SuppressWarnings(&quot;varargs&quot;)
    public static &lt;K extends Comparable&lt;K&gt;, V&gt; NavigableMap&lt;K, V&gt;
    sortedMap(MergeFunction mergeFunction, Map.Entry&lt;K,V&gt;... entriesArr) {
<span class="nc" id="L285">        return sortedMap(mergeFunction, Arrays.stream(entriesArr));</span>
    }

    /**
     * Transform the stream of entries into the sorted map,
     * where the entries with the same {@link Map.Entry#getKey() key} are merged
     * with the default merge-function {@link MergeFunction#OVERWRITE}.
     * &lt;hr/&gt;
     * In order to avoid {@link NullPointerException} all invalid entries are filtered out,
     * where the filter is based on using {@link #entryIsValid(Map.Entry)} function.
     *
     * @param entries stream of entries
     * @return the sorted map, which is collected from those entries, as {@link NavigableMap},
     * @param &lt;K&gt; the type of key that must implement {@link Comparable}
     * @param &lt;V&gt; the type of value
     */
    public static &lt;K extends Comparable&lt;K&gt;, V&gt; NavigableMap&lt;K, V&gt;
    sortedMap(Stream&lt;Map.Entry&lt;K,V&gt;&gt; entries) {
<span class="fc" id="L303">        return entries</span>
<span class="pc bpc" id="L304" title="2 of 6 branches missed.">            .filter(e -&gt; e != null &amp;&amp; e.getKey() != null &amp;&amp; e.getValue() != null)</span>
<span class="fc" id="L305">            .collect(toSortedMap(Map.Entry::getKey, Map.Entry::getValue));</span>
    }

    /**
     * Transform the stream of entries into the sorted map,
     * where the entries with the same {@link Map.Entry#getKey() key} are merged
     * with the passed {@code mergeFunction}.
     * &lt;hr/&gt;
     * In order to avoid {@link NullPointerException} all invalid entries are filtered out,
     * where the filter is based on using {@link #entryIsValid(Map.Entry)} function.
     *
     * @param mergeFunction the merge-function to handle the entries with the same {@link Map.Entry#getKey() key}
     * @param entries stream of entries
     * @return the sorted map, which is collected from those entries, as {@link NavigableMap},
     * @param &lt;K&gt; the type of key that must implement {@link Comparable}
     * @param &lt;V&gt; the type of value
     */
    public static &lt;K extends Comparable&lt;K&gt;, V&gt; NavigableMap&lt;K, V&gt;
    sortedMap(MergeFunction mergeFunction, Stream&lt;Map.Entry&lt;K,V&gt;&gt; entries) {
<span class="fc" id="L324">        return entries.collect(toSortedMap(Map.Entry::getKey, Map.Entry::getValue, mergeFunction));</span>
    }

    /**
     * Returns to sorted copy of the passed map {@code mapToSort}
     *
     * @param mapToSort the map whose sorted copy to return
     * @return the sorted copy of the passed map {@code mapToSort}
     * @param &lt;K&gt; the type of key that must implement {@link Comparable}
     * @param &lt;V&gt; the type of value
     */
    public static &lt;K extends Comparable&lt;K&gt;, V&gt; NavigableMap&lt;K, V&gt;
    sortedMap(Map&lt;K,V&gt; mapToSort) {
<span class="fc" id="L337">        return sortedMap(mapToSort.entrySet().stream());</span>
    }

    /**
     * Transform the var-args-arrays of entries into the linked map,
     * where the entries with the same {@link Map.Entry#getKey() key} are merged
     * with the default merge-function {@link MergeFunction#OVERWRITE}.
     * &lt;hr/&gt;
     * In order to avoid {@link NullPointerException} all invalid entries are filtered out,
     * where the filter is based on using {@link #entryIsValid(Map.Entry)} function.
     *
     * @param entriesArr var-args-arrays of entries
     * @return the linked map, which is collected from {@code entries}, as {@link SequencedMap},
     * @param &lt;K&gt; the type of key
     * @param &lt;V&gt; the type of value
     */
    @SafeVarargs
    @SuppressWarnings(&quot;varargs&quot;)
    public static &lt;K, V&gt; SequencedMap&lt;K, V&gt;
    linkedMap(Map.Entry&lt;K,V&gt;... entriesArr) {
<span class="fc" id="L357">        return linkedMap(Arrays.stream(entriesArr).filter(CoreStreamUtils::entryIsValid));</span>
    }

    /**
     * Transform the var-args-arrays of entries into the linked map,
     * where the entries with the same {@link Map.Entry#getKey() key} are merged
     * with the passed {@code mergeFunction}.
     * &lt;hr/&gt;
     * In order to avoid {@link NullPointerException} all invalid entries are filtered out,
     * where the filter is based on using {@link #entryIsValid(Map.Entry)} function.
     *
     * @param mergeFunction the merge-function to handle the entries with the same {@link Map.Entry#getKey() key}
     * @param entriesArr var-args-arrays of entries
     * @return the linked map, which is collected from {@code entries}, as {@link SequencedMap},
     * @param &lt;K&gt; the type of key
     * @param &lt;V&gt; the type of value
     */
    @SafeVarargs
    @SuppressWarnings(&quot;varargs&quot;)
    public static &lt;K, V&gt; SequencedMap&lt;K, V&gt;
    linkedMap(MergeFunction mergeFunction, Map.Entry&lt;K,V&gt;... entriesArr) {
<span class="nc" id="L378">        return linkedMap(mergeFunction, Arrays.stream(entriesArr));</span>
    }

    /**
     * Transform the stream of entries into the linked map,
     * where the entries with the same {@link Map.Entry#getKey() key} are merged
     * with the default merge-function {@link MergeFunction#OVERWRITE}.
     * &lt;hr/&gt;
     * In order to avoid {@link NullPointerException} all invalid entries are filtered out,
     * where the filter is based on using {@link #entryIsValid(Map.Entry)} function.
     *
     * @param entries stream of entries
     * @return the linked map, which is collected from {@code entries}, as {@link SequencedMap},
     * @param &lt;K&gt; the type of key
     * @param &lt;V&gt; the type of value
     */
    public static &lt;K, V&gt; SequencedMap&lt;K, V&gt;
    linkedMap(Stream&lt;Map.Entry&lt;K,V&gt;&gt; entries) {
<span class="fc" id="L396">        return entries.collect(toLinkedMap(Map.Entry::getKey, Map.Entry::getValue));</span>
    }

    /**
     * Transform the var-args-arrays of entries into the linked map,
     * where the entries with the same {@link Map.Entry#getKey() key} are merged
     * with the passed {@code mergeFunction}.
     * &lt;hr/&gt;
     * In order to avoid {@link NullPointerException} all invalid entries are filtered out,
     * where the filter is based on using {@link #entryIsValid(Map.Entry)} function.
     *
     * @param mergeFunction the merge-function to handle the entries with the same {@link Map.Entry#getKey() key}
     * @param entries stream of entries
     * @return the linked map, which is collected from {@code entries}, as {@link SequencedMap},
     * @param &lt;K&gt; the type of key
     * @param &lt;V&gt; the type of value
     */
    public static &lt;K, V&gt; SequencedMap&lt;K, V&gt;
    linkedMap(MergeFunction mergeFunction, Stream&lt;Map.Entry&lt;K,V&gt;&gt; entries) {
<span class="fc" id="L415">        return entries.collect(toLinkedMap(Map.Entry::getKey, Map.Entry::getValue, mergeFunction));</span>
    }

    /**
     * In order to avoid {@link NullPointerException} in JDK's collectors
     * all entries that are {@code null} or whose key or value is {@code null} should be filtered out.
     *
     * @param entry an entry to filter
     * @return {@code true} if the entry is valid and otherwise - {@code false}
     */
    public static boolean entryIsValid(Map.Entry&lt;?,?&gt; entry) {
<span class="fc bfc" id="L426" title="All 6 branches covered.">        return entry != null &amp;&amp; entry.getKey() != null &amp;&amp; entry.getValue() != null;</span>
    }

    // --------------------------------------------------------------------------------------------

<span class="fc" id="L431">    private CoreStreamUtils() {</span>
        // prohibit the creation of utility-class instance
<span class="fc" id="L433">        throw new UnsupportedOperationException(&quot;Cannot instantiate utility-class &quot; + getClass().getName());</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.14.202510111229</span></div></body></html>